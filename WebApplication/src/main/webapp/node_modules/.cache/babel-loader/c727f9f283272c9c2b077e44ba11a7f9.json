{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time') : void 0;\n    prompt = nextPrompt;\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : void 0;\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(listener) {\n    listeners.push(listener);\n    return function () {\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\nexports.default = createTransitionManager;","map":{"version":3,"sources":["C:/Users/Cagri Eren/Documents/GitHub/Tubitak_yte_intern_project/src/main/webapp/node_modules/history/createTransitionManager.js"],"names":["exports","__esModule","_warning","require","_warning2","_interopRequireDefault","obj","default","createTransitionManager","prompt","setPrompt","nextPrompt","process","env","NODE_ENV","confirmTransitionTo","location","action","getUserConfirmation","callback","result","listeners","appendListener","listener","push","filter","item","notifyListeners","_len","arguments","length","args","Array","_key","forEach","apply","undefined"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar createTransitionManager = function createTransitionManager() {\n  var prompt = null;\n\n  var setPrompt = function setPrompt(nextPrompt) {\n    process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(prompt == null, 'A history supports only one prompt at a time') : void 0;\n\n    prompt = nextPrompt;\n\n    return function () {\n      if (prompt === nextPrompt) prompt = null;\n    };\n  };\n\n  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {\n    // TODO: If another transition starts while we're still confirming\n    // the previous one, we may end up in a weird state. Figure out the\n    // best way to handle this.\n    if (prompt != null) {\n      var result = typeof prompt === 'function' ? prompt(location, action) : prompt;\n\n      if (typeof result === 'string') {\n        if (typeof getUserConfirmation === 'function') {\n          getUserConfirmation(result, callback);\n        } else {\n          process.env.NODE_ENV !== 'production' ? (0, _warning2.default)(false, 'A history needs a getUserConfirmation function in order to use a prompt message') : void 0;\n\n          callback(true);\n        }\n      } else {\n        // Return false from a transition hook to cancel the transition.\n        callback(result !== false);\n      }\n    } else {\n      callback(true);\n    }\n  };\n\n  var listeners = [];\n\n  var appendListener = function appendListener(listener) {\n    listeners.push(listener);\n\n    return function () {\n      listeners = listeners.filter(function (item) {\n        return item !== listener;\n      });\n    };\n  };\n\n  var notifyListeners = function notifyListeners() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return listeners.forEach(function (listener) {\n      return listener.apply(undefined, args);\n    });\n  };\n\n  return {\n    setPrompt: setPrompt,\n    confirmTransitionTo: confirmTransitionTo,\n    appendListener: appendListener,\n    notifyListeners: notifyListeners\n  };\n};\n\nexports.default = createTransitionManager;"]},"metadata":{},"sourceType":"script"}